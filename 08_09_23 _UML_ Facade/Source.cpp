/*
* 
* ............................Паттерны поведения...................................
* .................................................
* Существуют несколько типов паттернов проектирования, каждый из которых предназначен для решения своего круга задач:

 Порождающие паттерны, предназначенные для создания новых объектов в системе.
 Структурные паттерны, решающие задачи компоновки системы на основе классов и объектов.
 Паттерны поведения, предназначенные для распределения обязанностей между объектами в системе.
  Facade Camera, Command, Mediator, templeate , ITERATOR,  State
* 08_09_23 _UML_ Facade Camera_Mediator_Command_ITERATOR_Strategi_State 
* .................................................

Facade Camera Паттерны поведения

+ Мы максимизируем принципы SRP
+ На счет открытости \ закрытости Расширять под капотом можно сколько угодно.
 
 //////////////////////////////////////
 Плюсы использования фасадного класса в UML для C++ включают:
 Плюсы
 1)Простота: Фасад обеспечивает простой интерфейс для сложной системы или подсистемы, делая его более простым для понимания и использования.
 2)Инкапсуляция: Фасад может скрывать детали реализации внутренних компонентов, обеспечивая гибкость и возможность внесения изменений без влияния на клиентов.
 3)Модульность: Фасад позволяет разделить систему на модули, предоставляя доступ только к тем функциям, которые необходимы клиенту.
 4)Тестируемость: Фасад упрощает тестирование внутренней системы, так как клиенты взаимодействуют только с фасадом.
 5)Улучшение связности: Фасад может помочь улучшить связность кода, объединяя связанные функции и скрывая неважные детали.

Минусы использования фасадного класса могут включать:

1)Сложность: Фасады могут сделать систему более сложной, особенно если они скрывают слишком много деталей.
2)Возможность введения ошибок: Если фасад написан неправильно, он может скрыть ошибки или сделать их более трудными для обнаружения.
3) Замедление работы: Фасады требуют дополнительных вычислений и времени на обработку, особенно если они обрабатывают большое количество данных.
 //////////////////////////////////////
 /*
 В UML фасад изображается как класс с кругами на сторонах. Вот пример, как это может выглядеть:

interface Camera {
    // ...
}

class MobilePhone {
    // ...
}

class CameraPhone : Camera, MobilePhone {
    // ...
}

class CameraManagerFacade {
    Camera camera = / ... /
MobilePhone mobilePhone = / ... /

void takePicture() {
    // ... use camera ...
}

void makeCall() {
    // ... use mobile phone ...
}
}
В этом примере мы имеем дело с интерфейсом Camera и интерфейсом MobilePhone.Мы можем создать класс CameraPhone,
который реализует оба этих интерфейса.Однако, если мы хотим создать объект, который имеет только методы для работы
с камерой и для совершения звонков, мы можем использовать фасад CameraManagerFacade.
Этот класс инкапсулирует объект Camera и объект MobilePhone внутри себя, и предоставляет методы takePicture() и makeCall(),
которые используют эти объекты для выполнения соответствующих действий.


........................................................
В UML фасад обозначается как класс с кружочками на сторонах. Например:

class Camera
class MobilePhone
class CameraPhone: Camera, MobilePhone
Здесь у нас есть классы Camera и MobilePhone, и класс CameraPhone, который наследует от них.
Но что если мы хотим работать только с методами камеры и телефона, и не хотим иметь дело с их деталями реализации?
В этом случае мы можем использовать фасад:

class CameraManagerFacade

void CameraManagerFacade::takePicture()
{
    // код для работы с камерой
}

void CameraManagerFacade::makeCall()
{
    // код для совершения звонка
}
Этот класс предоставляет методы для работы только с камерой и телефоном, скрывая детали их реализации.
........................................................................
///////////////////////////////////////////

Паттерн Command  

Паттерны поведения
Реализует принцип Открытости и \ Закрытоси
Можно вызвать команду и поьлзоваться ее выполнением / но нелья поменять что либо подд капотом

Паттерн Command ..........отделяет........... объект, инициирующий операцию, от объекта, который знает, как ее выполнить.
цель : Инкапсулирует команды в некотором объекте.
Это команды Ж Действие, Транзакция, Сохранить и тд....

Command Убирает прямую зависимость между объектами вызываемыми команду и объектами исполняющие эту команду.


Паттерн Command (Команда) - это поведенческий паттерн проектирования, который позволяет отделить алгоритм от объекта,
выполняющего этот алгоритм. Он позволяет заменить один объект другим без изменения алгоритма. 
Паттерн Command часто используется для обработки событий в графических интерфейсах пользователя,
когда нужно выполнить действие в ответ на событие, но само действие может быть изменено без изменения кода обработки события.

Паттерн Command 
Пример: Кнопка
должна при нажатии выполняла одно действие.
Должны передать этой кнопке действие коорое она должна вызвать

Разные системы в действие должны вызывать одну и туже операцию!!

Пример: Сохранить документ 
Мы нажатием клавиш можем сохранитьЮ мы одной кнопкой можем сохранить
Вывод Одино и тоже действие выполняется разными действиями

Реализация паттерна Command
Рассмотрим реализацию паттерна Command на примере игры «Шахматы». Имитируем возможность выполнения следующих операций:

Создать новую игру.
Открыть существующую игру.
Сохранить игру.
Сделать очередной ход.
Отменить последний ход.

#include<iostream>
#include<vector>
#include<string>

class Game
{
  public:
    void create( ) {
      cout << "Create game " << endl;
    }
    void open( string file ) {
      cout << "Open game from " << file << endl;
    }
    void save( string file ) {
      cout << "Save game in " << file << endl;
    }
    void make_move( string move ) {
      cout << "Make move " << move << endl;
    }
};

string getPlayerInput( string prompt ) {
  string input;
  cout << prompt;
  cin >> input;
  return input;
}

// Базовый класс
class Command
{
  public:
    virtual ~Command() {}
    virtual void execute() = 0;
  protected:
    Command( Game* p ): pgame( p) {}
    Game * pgame;
};

class CreateGameCommand: public Command
{
  public:
    CreateGameCommand( Game * p ) : Command( p) {}
    void execute() {
      pgame->create( );
    }
};

class OpenGameCommand: public Command
{
  public:
    OpenGameCommand( Game * p ) : Command( p) {}
    void execute() {
      string file_name;
      file_name = getPlayerInput( "Enter file name:");
      pgame->open( file_name);
    }
};

class SaveGameCommand: public Command
{
  public:
    SaveGameCommand( Game * p ) : Command( p) {}
    void execute( ) {
      string file_name;
      file_name = getPlayerInput( "Enter file name:");
      pgame->save( file_name);
    }
};

class MakeMoveCommand: public Command
{
  public:
    MakeMoveCommand( Game * p) : Command( p) {}
    void execute() {
      // Сохраним игру для возможного последующего отката
      pgame->save( "TEMP_FILE");
      string move;
      move = getPlayerInput( "Enter your move:");
      pgame->make_move( move);
    }
};

class UndoCommand: public Command
{
  public:
    UndoCommand( Game * p ) : Command( p) {}
    void execute() {
      // Восстановим игру из временного файла
      pgame->open( "TEMP_FILE");
    }
};


int main()
{
  Game game;
  // Имитация действий игрока
  vector<Command*> v;
  // Создаем новую игру
  v.push_back( new CreateGameCommand( &game));
  // Делаем несколько ходов
  v.push_back( new MakeMoveCommand( &game));
  v.push_back( new MakeMoveCommand( &game));
  // Последний ход отменяем
  v.push_back( new UndoCommand( &game));
  // Сохраняем игру
  v.push_back( new SaveGameCommand( &game));

  for (size_t i=0; i<v.size(); ++i)
    v[i]->execute();

  for (size_t i=0; i<v.size(); ++i)
    delete v[i];

  return 0;
}

///////////////////////////////////////////////////////////////////////////////

Паттерн Шаблонный метод templeate

- Жостко ограничены скелетом класса (Алгоритма)
- Можем нарушить контракт класса, Изменяя базовое поведение одного посредством подкласса 
- С ростом количества шагов, шаблонный метод становиться слишком сложно поддерживать
(Просто каждый шаг это дополнительная ответственность , дополнительное изменение )
Это нарушение SRP - Это как GOD класс.

+ В идеале работать удобно если шаков не больше 3. Иначе он усложняется.

templateMethod() {
    // Общий алгоритм
    method1()
    method2()
    ...
    methodN()
}

.................Интерфейс:...................

abstract class TemplatePattern {
    abstract method1();
    ...
    abstract methodN();

    public methodTemplate() {
        // Общий алгоритм
        method1()
        ...
        methodN()
    }
}

class ConcretePattern1 extends TemplatePattern {
    override method1() {...}
    ...
    override methodN() {...}
}
...
class ConcretePatternN extends TemplatePattern {
    override method1() {...}
    ...
    override methodN() {...}
}

Паттерн “Шаблонный метод” используется для обеспечения базового алгоритма, 
который может быть переопределен в подклассах.
Это позволяет подклассам изменять поведение без изменения базового алгоритма.

////////////////////////////////////////////////////////////
 Медиатор Класс.

 Когда есть связь между модулями программы то ось изменений проходит так что 
 При изменении чего либо надо поменять все.
 Медиатор решает эти проблемы - И связь идет только через медиатор
 ............................................................
 В С++ паттерн проектирования “Медиатор” не имеет каких-то специфических плюсов или минусов,
 так как он является общим принципом организации архитектуры программного обеспечения. 
 Вот некоторые общие преимущества и недостатки использования паттерна проектирования “Медиатор”:

Преимущества:

– Уменьшение связанности между компонентами системы. Медиатор позволяет изолировать взаимодействие между объектами
и упростить их изменение или замену.
– Улучшение модульности системы. Медиатор определяет интерфейс взаимодействия между объектами, 
что позволяет легко добавлять или удалять компоненты без необходимости изменения других частей системы.
– Возможность изменения последовательности выполнения операций. Медиатор может определять порядок выполнения
операций и позволять его изменение без влияния на другие компоненты системы.

Недостатки:

– Сложность проектирования и реализации. Разработка и внедрение паттерна “Медиатор” может потребовать больше времени и усилий,
чем простое прямое взаимодействие между объектами.
– Увеличение количества объектов и уровней абстракции. Использование медиатора может привести к увеличению количества объектов 
и усложнению системы.
– Не всегда оптимальное использование памяти. Создание и управление дополнительными объектами может привести 
к дополнительным расходам памяти и снижению производительности.

Важно понимать, что выбор паттерна проектирования, включая “Медиатор”, должен быть основан на конкретных требованиях 
и особенностях проекта.
 ............................................................

 Медиатор это способ разрешить проблему архитектуры в приложении.

 //////////////////////////////////////////////////////////////////////
 Паттерн  ITERATOR

 Итератор без коллекции не может существовать

 цель: Дать возможность последовательно обходить элементы составных объектов
 не раскрывая их внутреннего представления

 Паттерн итератор (iterator) предоставляет механизм для перебора элементов в коллекции без знания 
 её внутреннего представления. Он позволяет выполнять различные операции над элементами коллекции
 (например, получать, удалять или изменять их), не раскрывая её внутреннего представления.

  Это все со схемы
 Итератор - описывает интерфейс для доступа и обхода элементов коллекции

 Итератор - Реализует алгоритм обхода какой то коллекции
 Коллекция - описывает интерфейс получения итератора из коллекции

 Конкретная коллекция возвращает экземпляр определенного конкретного итратора.

 Паттерн итератор (iterator) - Позволяет
 Скрытие от клиента детали реализации
 Введение вариативности в способы обхода коллекции
 Вы получаете единый интерфейс обхода коллекции.

 Паттерн итератор (iterator) - 
 + Позволяет реализовать различные способы обхода
 + Упрощает хранение данных
 + Позволяет одновременно перемещаться по коллекции


 ПРИМЕР КОДА 
 
 * Паттерн Итератор
 *
 * Назначение: Даёт возможность последовательно обходить элементы составных
 * объектов, не раскрывая их внутреннего представления.
 

#include <iostream>
#include <string>
#include <vector>

 
  * C++ имеет собственную реализацию итератора, которая работает
  * с другими обобщенными контейнерами, определенными
  * в стандартной библиотеке.
 

template <typename T, typename U>
class Iterator {
public:
    typedef typename std::vector<T>::iterator iter_type;
    Iterator(U* p_data, bool reverse = false) : m_p_data_(p_data) {
        m_it_ = m_p_data_->m_data_.begin();
    }

    void First() {
        m_it_ = m_p_data_->m_data_.begin();
    }

    void Next() {
        m_it_++;
    }

    bool IsDone() {
        return (m_it_ == m_p_data_->m_data_.end());
    }

    iter_type Current() {
        return m_it_;
    }

private:
    U* m_p_data_;
    iter_type m_it_;
};


  Конкретные Коллекции предоставляют один или несколько методов для получения
  новых экземпляров итератора, совместимых с классом коллекции.
 

template <class T>
class Container {
    friend class Iterator<T, Container>;

public:
    void Add(T a) {
        m_data_.push_back(a);
    }

    Iterator<T, Container>* CreateIterator() {
        return new Iterator<T, Container>(this);
    }

private:
    std::vector<T> m_data_;
};

class Data {
public:
    Data(int a = 0) : m_data_(a) {}

    void set_data(int a) {
        m_data_ = a;
    }

    int data() {
        return m_data_;
    }

private:
    int m_data_;
};


 * Клиентский код может знать или не знать о классах конкретного итератора или
 * коллекции, для этой реализации контейнер является универсальным,
 * поэтому вы можете использовать его с int или с пользовательским классом.
 

void ClientCode() {
    std::cout << "________________Iterator with int______________________________________" << std::endl;
    Container<int> cont;

    for (int i = 0; i < 10; i++) {
        cont.Add(i);
    }

    Iterator<int, Container<int>>* it = cont.CreateIterator();
    for (it->First(); !it->IsDone(); it->Next()) {
        std::cout << *it->Current() << std::endl;
    }

    Container<Data> cont2;
    Data a(100), b(1000), c(10000);
    cont2.Add(a);
    cont2.Add(b);
    cont2.Add(c);

    std::cout << "________________Iterator with custom Class______________________________" << std::endl;
    Iterator<Data, Container<Data>>* it2 = cont2.CreateIterator();
    for (it2->First(); !it2->IsDone(); it2->Next()) {
        std::cout << it2->Current()->data() << std::endl;
    }
    delete it;
    delete it2;
}

int main() {
    ClientCode();
    return 0;
}

/////////////////////////////////////////////////////////////////////
Паттерн Strategy Стартегия

Уход от наследования к Делегированию
(Поменьше наследования)

 цель: Взаимозаменять алгоритмы прямо во время выполнения программы
 В коде есть объект который может менять в зависимости от поведения программы

 В целом шаблон «Стратегия» — это полезный шаблон проектирования, 
 который позволяет динамически выбирать поведение объекта во время выполнения, 
 обеспечивая гибкость, модульность и возможность тестирования.
 ........................................................
 Паттерн Strategy позволяет определить набор алгоритмов, которые могут быть выбраны во время выполнения программы.
 Это может быть полезно, например, для обработки различных типов данных или для выполнения различных операций 
 в зависимости от условий.
 В C++ паттерн Strategy реализуется с помощью наследования и виртуальных функций.
 ..........................................................

 Преимущества:

 Семейство алгоритмов можно определить как иерархию классов и взаимозаменяемо использовать для изменения поведения приложения
без изменения его архитектуры.
Инкапсулируя алгоритм отдельно, можно легко ввести новые алгоритмы, соответствующие тому же интерфейсу.
Приложение может переключать стратегии во время выполнения.
Стратегия позволяет клиентам выбирать необходимый алгоритм без использования оператора «switch» или серии операторов «if-else».
Структуры данных, используемые для реализации алгоритма, полностью инкапсулированы в классы стратегий. Следовательно,
реализацию алгоритма можно изменить, не затрагивая класс Context.

Недостатки:

 Приложение должно знать обо всех стратегиях, чтобы выбрать правильную для конкретной ситуации.
Классы Context и Strategy обычно взаимодействуют через интерфейс, заданный абстрактным базовым классом Strategy.
Базовый класс стратегии должен предоставлять интерфейс для всех необходимых действий,
которые некоторые конкретные классы стратегии могут не реализовать.
В большинстве случаев приложение настраивает Контекст с необходимым объектом Стратегии. Следовательно,
приложению необходимо создавать и поддерживать два объекта вместо одного.

Пример: Карта
Удобна когда мы в Опциях галочки ставим
Стратегия Делает одно и тоже но с учетом выбранных галочками данных.
Тоесть программа делает одно и тоже но по другими данными.


Шаблон «Стратегия» предоставляет ряд преимуществ, в том числе:

Гибкость: шаблон «Стратегия» позволяет динамически изменять поведение объекта во время выполнения, 
выбирая различные алгоритмы.
Модульность: шаблон инкапсулирует алгоритмы в отдельные классы, что позволяет легко добавлять или удалять алгоритмы,
не затрагивая другие части кода.
Тестируемость: шаблон позволяет легко тестировать различные алгоритмы по отдельности, не влияя на общее поведение кода.
Принцип открытости-закрытости. Шаблон стратегии следует принципу открытости-закрытости, который гласит,
что класс должен быть открыт для расширения, но закрыт для модификации.
Однако шаблон «Стратегия» также может иметь некоторые недостатки, в том числе повышенную сложность из-за использования нескольких
классов и потенциальные проблемы с производительностью, если выбор алгоритмов часто выполняется во время выполнения.

Уход от наследования к Делегированию
(Это значит - Делегировать выполнение работы в другой класс - Тоесть передать работу другому)


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
State Паттерн Состояния

Дает возможность уменьшить if else если  Просто объект принимает определенное состояние. 
От контакта с наружи он принимает данные в условия которые по его пределам меняет состояние объекта. 

цель : Дать возможность объектам менять поведение в зависимости от его состояния
В коде есть объект  который должен менять свое поведение в зависимости от своего состояния

Отличие от Паттрена Стейт от Стратегии
в Стейт - Нельзя принять с наружи изменение состояния
А в Стратегии есть .
в Паттерне состояния Лучше реализуется когда поведение объекта можно описат с помощю конечных автоматов.
(конечных автоматов - это то что может работать само по себе Реализуется через switch casse:) -  тоесть автоматом работает.

С наружи метод Состояния менять неможет.
Само состояние изменяет объект в нутри что меняет стратегию. (swich case:)
 Активно используется в игровой разработке
 (Пропадает огромное количество if из кода. ) 
 Атак метод В состоянии. Тейк демедж прилетает что она ранена. И он передает данные в В Состояние  меняется на раненное.



*/


